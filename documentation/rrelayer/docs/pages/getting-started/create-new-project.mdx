# Create New Project

:::info
Make sure you have the CLI installed before starting a new project.
You can find the installation instructions [here](/getting-started/installation).
:::

We advise anyone using rrelayer to install docker which makes running locally with postgres storage a lot easier.
If you not got docker you can install it [here](https://docs.docker.com/get-docker/).

## 1. Create a new project

This will walk you through setting up your project by asking you a series of questions in the terminal.

```bash
rrelayer new
```

### Example New

```bash
Initializing new rrelayer project...

Enter project name: MyFirstRelayer
Enter project description (skip by pressing Enter): My first rrelayer project
Do you want Docker support out of the box (will make it easy to run)? [Y/n]: Y

Project 'MyFirstRelayer' initialized successfully! note we advise to not use the RAW_DANGEROUS_MNEMONIC in production and use one of the secure key management signing keys. Alongside replace RRELAYER_AUTH_USERNAME and RRELAYER_AUTH_PASSWORD in the .env
```

Once completed, a new boilerplate project will be created in the current directory. You can navigate to the project directory and start building your project.
The boilerplate project is configured with sepolia ethereum testnet configured to be able to easily start it up.

## 2. Environment Variables

On creation, it will generate you a `.env` with some values it to make it easy to run by default it generates you signing provider raw which
is not the securest to run as the seed is in the `env`, but rrelayer offers many signing key providers which you can find out more [here](/config/signing-providers/aws-kms).

The `.env` file will look something like this:

```bash
RAW_DANGEROUS_MNEMONIC="RANDOM SEED PHRASE"
DATABASE_URL=postgresql://postgres:rrelayer@localhost:5441/postgres # will say FILL_IN if you did not pick docker support out the box
POSTGRES_PASSWORD=rrelayer # will only be here if you picked docker support out the box
RRELAYER_AUTH_USERNAME=development_username_h6BOwhxo # these are randomly generated and on deployment you should use production keys
RRELAYER_AUTH_PASSWORD=development_password_jkmxXj7pAUcCk67z # these are randomly generated and on deployment you should use production keys
```

### RAW_DANGEROUS_MNEMONIC

This is just a seed phrase in the env file as said you can use many more secure key providers, but we do this to be easy to just run off the bat.
rrelayer offers many signing key providers which you can find out more [here](/config/signing-providers/aws-kms).

### DATABASE_URL

For ease of running locally we suggest you enable docker support on the rrelayer project, if you did not
enable docker support you will need to provide a `DATABASE_URL` in the `.env` file
which has been generated for you.

`sslmode=require` is supported as well just include it in the connection string.

### POSTGRES_PASSWORD - docker only

This is injected into the `.env` for your if you selected `yes` to the `Postgres Docker Support Out The Box?` question.
This is used for the docker to create a postgres database for you locally. You do not need this if you have your own postgres database or
on deployed environments. It is purely for local development.

```bash
POSTGRES_PASSWORD=password
```

### RRELAYER_AUTH_USERNAME

:::info
This is just the name of the environment variable rrelayer spins up you can rename it anything and map it in the `rrelayer.yaml`.
:::

rrelayer uses basic auth to allow you to config who can hit the rrelayer API, so this is the username used, you should replace it
with one which is more secure before you deploy this to production. Note if anyone gets these details, they can hit your relayers.

### RRELAYER_AUTH_PASSWORD

:::info
This is just the name of the environment variable rrelayer spins up you can rename it anything and map it in the `rrelayer.yaml`.
:::

rrelayer uses basic auth to allow you to config who can hit the rrelayer API, so this is the password used, you should replace it
with one which is more secure before you deploy this to production. Note if anyone gets these details, they can hit your relayers.

### Other Environment Variables

Every part of the `rrelayer.yaml` file can be overridden by an environment variable.
The syntax for this in the `rrelayer.yaml` is `${ENV_VARIABLE_NAME}` example `${RRELAYER_AUTH_USERNAME}`. This can be used in ANY field in the YAML file.
Read more about the environment variables in the [yaml configuration documentation](/config#environment-variables).

## 3. Config your `rrelayer.yaml` file

Generating a rrelayer project will generate a `rrelayer.yaml` file for you. This is where you will configure your project.
You can read all about the rrelayer.yaml settings in the [yaml configuration documentation](/config).

It will generate you an boilerplate project which is configured to sepolia ethereum network.

:::warning
The boilerplate template uses no gas price provider that means it's estimating the gas prices from the last blocks as the fallback.
To get more exact prices, we recommend you setting up one of the supported gas price providers which you can find more info on [here](/config/networks/gas-provider#gas-provider---optional).
:::

```yaml
name: first-rrelayer
description: 'my first rrelayer'
api_config:
  port: 8000
  authentication_username: ${RRELAYER_AUTH_USERNAME}
  authentication_password: ${RRELAYER_AUTH_PASSWORD}
signing_provider:
  raw:
    mnemonic: ${RAW_DANGEROUS_MNEMONIC}
networks:
  - name: sepolia_ethereum
    chain_id: 11155111
    provider_urls:
      - https://sepolia.gateway.tenderly.co
    block_explorer_url: https://sepolia.etherscan.io
    max_gas_price_multiplier: 4
    gas_bump_blocks_every:
      slow: 10
      medium: 5
      fast: 4
      super_fast: 2
```

## 4. Start the project

:::info
rrelayer starts your postgres docker compose file up for you automatically if the DATABASE_URL can not connect to the database and docker-compose.yml is present in the parent directory.
You will need to make sure you have docker running on your machine before starting the project. If you have not got docker you can install it [here](https://docs.docker.com/get-docker/).
You can also run docker manually by using `docker compose up -d`.
:::

to run make sure your in your rrelayer project and then run:

```bash
rrelayer start
...
26 September - 12:59:27.131388  INFO Loading from path "/Users/josh/code/rrelayer/playground/example"
26 September - 12:59:27.132224  INFO Starting relayer...
26 September - 12:59:27.380866  INFO Docker starting up the postgres container..
26 September - 12:59:27.440710  INFO All containers are up and running.
26 September - 12:59:27.440776  INFO Docker postgres containers started up successfully
26 September - 12:59:27.501688  INFO Starting up the server
26 September - 12:59:27.615170  INFO Applied database schema
26 September - 12:59:27.849761  INFO Calculated block time: 12s (12000ms), limited to 12000ms
26 September - 12:59:27.849924  INFO Webhooks disabled - no webhook configuration found
26 September - 12:59:28.072807  INFO Creating new TransactionsQueue for relayer: 96578090-068b-4caa-85fa-2d106c55564f (name: relayer1) on chain: 11155111
26 September - 12:59:28.130062  INFO Starting background tasks
26 September - 12:59:28.130242  INFO Getting initial gas price for provider: sepolia_ethereum
26 September - 12:59:28.130288  INFO Getting initial blob gas price for provider: sepolia_ethereum
26 September - 12:59:28.130305  INFO Starting automatic top-up task
26 September - 12:59:28.130367  INFO Starting automatic top-up background task
26 September - 12:59:28.162981  INFO Initial blob gas price collection completed for all blob-supporting providers
26 September - 12:59:28.163018  INFO Starting blob_gas_oracle interval for provider: sepolia_ethereum
26 September - 12:59:30.445777  INFO Initial gas price collection completed for all providers
26 September - 12:59:30.445828  INFO Starting gas_oracle interval for provider: sepolia_ethereum
26 September - 12:59:30.445847  INFO Background tasks spawned up
26 September - 12:59:30.445856  INFO Rate limiting disabled - no configuration found
26 September - 12:59:30.447145  INFO rrelayer is up on http://localhost:8000
```

:::warning
The boilerplate template uses a free rpc node which may get rate limited. We recommend using a paid node for production.
:::

## 5. Create your first relayer

:::code-group

```bash [curl]
curl -X POST http://localhost:8000/api/relayers/11155111/new \
  -u "username:password" \
  -H "Content-Type: application/json" \
  -d '{"name": "my-first-relayer"}'

# {
#   id: 'd6dd6bcc-6a7d-4645-bf83-663da3bae8cd',
#   address: '0x7a0f605c8366373764760673020b6b2d8574f3f2'
# }
```

```ts [node]
// client.ts
import {createClient} from "rrelayer";
import * as dotenv from "dotenv";

dotenv.config();

export const client = createClient({
    serverUrl: 'http://localhost:8000',
    auth: {
        username: process.env.RRELAYER_AUTH_USERNAME!,
        password: process.env.RRELAYER_AUTH_PASSWORD!,
    },
});

...
// send-transaction.ts
import {client} from "./client";

let createdResult = await client.relayer.create(8453, 'fancy-relayer');
console.log(createdResult)
// createdResult {
//   id: 'd6dd6bcc-6a7d-4645-bf83-663da3bae8cd',
//   address: '0x7a0f605c8366373764760673020b6b2d8574f3f2'
// }
```

```rust [rust]
use anyhow::Result;
use rrelayer::{
    Client, CreateClientAuth, CreateClientConfig, CreateRelayerResult, TransactionSpeed,
    create_client,
};
use dotenvy::dotenv;
use std::env;

async fn get_client() -> Result<Client> {
    dotenv().ok();

    let username = env::var("RRELAYER_AUTH_USERNAME")
        .expect("RRELAYER_AUTH_USERNAME must be set");

    let password = env::var("RRELAYER_AUTH_PASSWORD")
        .expect("RRELAYER_AUTH_PASSWORD must be set");

    let client = create_client(CreateClientConfig {
        server_url: "http://localhost:8000".to_string(),
        auth: CreateClientAuth {
            username,
            password,
        },
    });

    Ok(client)
}

async fn example() -> Result<()> {
    let client = get_client().await?;

    let result: CreateRelayerResult =
        client.relayer().create(11155111, "fancy_relayer").await?;
    println!("{:?}", result);
    // result {
    //   id: 'd6dd6bcc-6a7d-4645-bf83-663da3bae8cd',
    //   address: '0x7a0f605c8366373764760673020b6b2d8574f3f2'
    // }

    let relayer_client =
        client.get_relayer_client(&result.id, Some(TransactionSpeed::FAST)).await?;

    Ok(())
}
```

:::

## 6. Sign your first message

:::code-group

```bash [curl]
curl -X POST https://your-rrelayer.com/api/signing/INSERT_RELAYER_ID/message \
  -u "username:password" \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Hello, World! Please sign this message to authenticate."
  }'

# result {
#  messageSigned: "Hello, World! Please sign this message to authenticate.",
#  signature: "0x8f3e5d2a1c4b7e9f6d8a2c5e1f4b7d9a3c6e8f1a4b7d9e2c5f8a1d4e7b9c2f5a8d1e4b7c9f2a5d8e1b4c7f9a2e5d8b1f4c7e9d2a5f8e1c4b7d9f2a5e8c1b",
#  signedBy: "0x7a0f605c8366373764760673020b6b2d8574f3f2"
#}
```

```ts [node]
// config.ts
import { createClient } from 'rrelayer';
import * as dotenv from "dotenv";
dotenv.config();

const client = createClient({
  serverUrl: 'http://localhost:8000',
  auth: {
    username: process.env.RRELAYER_AUTH_USERNAME!,
    password: process.env.RRELAYER_AUTH_PASSWORD!,
  },
});

export const relayerClient = await client.getRelayerClient(
  // The relayer id you want to connect to
  '94afb207-bb47-4392-9229-ba87e4d783cb',
  // This is optional it defaults to fast and is a fallback
  // You can override this with the transaction request
  TransactionSpeed.FAST
);

...

// sign-text.ts
import { relayerClient } from './config';

// Using a framework like viem and ethers is recommended here. Look under framework guides > TypeScript for them.
// returns a SignTextResult - import { SignTextResult } from 'rrelayer';
let result = await relayerClient.sign.text('sign this message');
console.log(result)
// result {
//  messageSigned: "Hello, World! Please sign this message to authenticate.",
//  signature: "0x8f3e5d2a1c4b7e9f6d8a2c5e1f4b7d9a3c6e8f1a4b7d9e2c5f8a1d4e7b9c2f5a8d1e4b7c9f2a5d8e1b4c7f9a2e5d8b1f4c7e9d2a5f8e1c4b7d9f2a5e8c1b",
//  signedBy: "0x7a0f605c8366373764760673020b6b2d8574f3f2"
// }
```

```rust [rust]
use anyhow::Result;
use rrelayer::{
    create_client, AdminRelayerClient, CreateClientAuth, CreateClientConfig, RelayerId,
    SignTextResult, TransactionSpeed,
};
use std::str::FromStr;
use dotenvy::dotenv;
use std::env;

async fn get_relayer_client() -> Result<AdminRelayerClient> {
    dotenv().ok();

    let username = env::var("RRELAYER_AUTH_USERNAME")
        .expect("RRELAYER_AUTH_USERNAME must be set");

    let password = env::var("RRELAYER_AUTH_PASSWORD")
        .expect("RRELAYER_AUTH_PASSWORD must be set");

    let client = create_client(CreateClientConfig {
        server_url: "http://localhost:8000".to_string(),
        auth: CreateClientAuth {
            username,
            password,
        },
    });

    let relayer_client: AdminRelayerClient = client
        .get_relayer_client(
            &RelayerId::from_str("94afb207-bb47-4392-9229-ba87e4d783cb")?,
            // This is optional it defaults to fast and is a fallback
            // You can override this with the transaction request
            Some(TransactionSpeed::FAST),
        )
        .await?;

    Ok(relayer_client)
}

async fn example() -> Result<()> {
    let relayer_client = get_relayer_client().await?;

    let result: SignTextResult = relayer_client.sign().text("sign this message", None).await?;
    println!("{:?}", result);
    // result {
    //  messageSigned: "Hello, World! Please sign this message to authenticate.",
    //  signature: "0x8f3e5d2a1c4b7e9f6d8a2c5e1f4b7d9a3c6e8f1a4b7d9e2c5f8a1d4e7b9c2f5a8d1e4b7c9f2a5d8e1b4c7f9a2e5d8b1f4c7e9d2a5f8e1c4b7d9f2a5e8c1b",
    //  signedBy: "0x7a0f605c8366373764760673020b6b2d8574f3f2"
    // }

    Ok(())
}
```

:::

## 7. Send your first transaction

:::code-group

```bash [curl]
curl -X POST https://your-rrelayer.com/api/transactions/relayers/YOUR_RELAYER_ID/send \
  -u "username:password" \
  -H "Content-Type: application/json" \
  -d '{
    "to": "0x1234567890abcdef1234567890abcdef12345678",
    "value": "1000000000000000000",
    "speed": "MEDIUM",
    "externalId": "order_12345"
  }'

# result {
#  "id": "94afb207-bb47-4392-9229-ba87e4d783cb",
#  "hash": "0xabcdef123456789abcdef123456789abcdef123456789abcdef123456789abcdef"
#}
```

```ts [node]
// config.ts
import { createClient, TransactionSpeed } from 'rrelayer';
import * as dotenv from "dotenv";
dotenv.config();

const client = createClient({
  serverUrl: 'http://localhost:8000',
  auth: {
    username: process.env.RRELAYER_AUTH_USERNAME!,
    password: process.env.RRELAYER_AUTH_PASSWORD!,
  },
});

export const relayerClient = await client.getRelayerClient(
  // The relayer id you want to connect to
  '94afb207-bb47-4392-9229-ba87e4d783cb',
  // This is optional it defaults to fast and is a fallback
  // You can override this with the transaction request
  TransactionSpeed.FAST
);

...

// send-eth-transaction.ts
import { relayerClient } from './config';
import { TransactionToSend } from 'rrelayer';

// Using a framework like viem and ethers is recommended here. Look under framework guides > TypeScript for them.
const txRequest: TransactionToSend = {
    to: '0x5FCD072a0BD58B6fa413031582E450FE724dba6D',
    value: '1000000000000000000'
};

// returns TransactionSent - import { TransactionSent } from 'rrelayer';
let response = await relayerClient.transaction.send(txRequest);
console.log(response);
// response {
//  "id": "94afb207-bb47-4392-9229-ba87e4d783cb",
//  "hash": "0xabcdef123456789abcdef123456789abcdef123456789abcdef123456789abcdef"
//}

// wait for the tx to be mined
// returns a TransactionReceipt - import { TransactionReceipt } from 'rrelayer';
let relayTransactionResult = await relayerClient.transaction.waitForTransactionReceiptById(
    response.id
);
```

```rust [rust]
use anyhow::Result;
use rrelayer::{
    AdminRelayerClient, CreateClientAuth, CreateClientConfig, EvmAddress, RelayTransactionRequest,
    RelayerId, SendTransactionResult, TransactionData, TransactionSpeed, TransactionValue,
    create_client,
};
use std::str::FromStr;
use dotenvy::dotenv;
use std::env;

async fn get_relayer_client() -> Result<AdminRelayerClient> {
    dotenv().ok();

    let username = env::var("RRELAYER_AUTH_USERNAME")
        .expect("RRELAYER_AUTH_USERNAME must be set");

    let password = env::var("RRELAYER_AUTH_PASSWORD")
        .expect("RRELAYER_AUTH_PASSWORD must be set");

    let client = create_client(CreateClientConfig {
        server_url: "http://localhost:8000".to_string(),
        auth: CreateClientAuth {
            username,
            password,
        },
    });

    let relayer_client: AdminRelayerClient = client
        .get_relayer_client(
            &RelayerId::from_str("94afb207-bb47-4392-9229-ba87e4d783cb")?,
            // This is optional it defaults to fast and is a fallback
            // You can override this with the transaction request
            Some(TransactionSpeed::FAST),
        )
        .await?;

    Ok(relayer_client)
}

async fn example() -> Result<()> {
    let relayer_client = get_relayer_client().await?;

    let request = RelayTransactionRequest {
        to: EvmAddress::from_str("0x5FCD072a0BD58B6fa413031582E450FE724dba6D")?,
        value: TransactionValue::from_str("1000000000000000000")
            .map_err(|e| anyhow::anyhow!("Invalid value: {}", e))?, // 1 ETH in wei
        data: TransactionData::empty(),
        // This is optional it defaults to what is set in the client creation
        // You can override this here per transaction if you wish though
        // speed: Some(TransactionSpeed::SUPER),
        external_id: None,
        blobs: None,
    };

    // Using a framework like alloy is recommended here. Look under framework guides > rust > alloy for it.
    let result: SendTransactionResult = relayer_client.transaction().send(&request, None).await?;
    println!("{:?}", result);
    // result {
    //  "id": "94afb207-bb47-4392-9229-ba87e4d783cb",
    //  "hash": "0xabcdef123456789abcdef123456789abcdef123456789abcdef123456789abcdef"
    //}

    // wait for the tx to be mined will return a receipt
    let relay_transaction_result =
        relayer_client.transaction().wait_for_transaction_receipt_by_id(&result.id).await?;
    println!("{:?}", relay_transaction_result);

    Ok(())
}
```

:::

Great you can learn more about all the features and integrations in the config and integration sections.
