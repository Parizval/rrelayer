use std::time::SystemTime;

use clap::Subcommand;
use rrelayerr_core::{
    relayer::types::RelayerId,
    transaction::types::{Transaction, TransactionId, TransactionStatus},
};
use rrelayerr_sdk::SDK;

use crate::{
    authentication::handle_authenticate, commands::keystore::ProjectLocation, console::print_table,
};

#[derive(Subcommand)]
pub enum TxCommand {
    /// Get transaction by ID
    Get {
        /// The transaction id which is generated by rrelayerr
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// Get transaction status by ID
    Status {
        /// The transaction id which is generated by rrelayerr
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// List transactions for a relayer
    List {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: String,

        /// Filter by status (pending, sent, failed, success)
        #[arg(long)]
        status: Option<TxStatus>,
    },
    /// List pending and mempool transactions
    Queue {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,
    },
    /// Cancel a transaction
    Cancel {
        /// The transaction id which is generated by rrelayerr
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// Replace a transaction
    Replace {
        /// The transaction id which is generated by rrelayerr
        #[clap(required = true)]
        tx_id: TransactionId,
    },
    /// Send a new transaction
    Send {
        /// Relayer ID
        #[clap(required = true)]
        relayer_id: RelayerId,
    },
}

#[derive(clap::ValueEnum, Clone)]
pub enum TxStatus {
    Pending,
    Sent,
    Failed,
    Success,
}

pub async fn handle_tx(
    command: &TxCommand,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), Box<dyn std::error::Error>> {
    match command {
        TxCommand::Get { tx_id } => handle_get(tx_id, project_path, sdk).await,
        // TxCommand::Status { tx_id } => handle_status(tx_id),
        // TxCommand::List(args) => handle_list(&args.relayer_id, args.status.as_ref()),
        // TxCommand::Queue { relayer_id } => handle_queue(relayer_id),
        // TxCommand::Cancel { tx_id } => handle_cancel(tx_id),
        // TxCommand::Replace { tx_id } => handle_replace(tx_id),
        // TxCommand::Send { relayer_id } => handle_send(relayer_id),
        _ => {
            panic!("Invalid command");
        }
    }
}

async fn handle_get(
    tx_id: &TransactionId,
    project_path: &ProjectLocation,
    sdk: &mut SDK,
) -> Result<(), Box<dyn std::error::Error>> {
    handle_authenticate(sdk, "account1", project_path).await?;

    let tx = sdk.transaction.get_transaction(tx_id).await?;
    if let Some(tx) = tx {
        log_transactions(vec![tx])?;
    } else {
        println!("Transaction {} not found.", tx_id);
    }
    Ok(())
}

fn handle_status(tx_id: &TransactionId) -> Result<(), Box<dyn std::error::Error>> {
    println!("Getting transaction status for ID: {}", tx_id);
    // TODO: Implement status checking logic
    Ok(())
}

fn handle_list(
    relayer_id: &RelayerId,
    status: Option<&TxStatus>,
) -> Result<(), Box<dyn std::error::Error>> {
    match status {
        Some(status) => println!("Listing transactions for relayer: {}", relayer_id),
        None => println!("Listing all transactions for relayer: {}", relayer_id),
    }
    // TODO: Implement transaction listing logic
    Ok(())
}

fn handle_queue(relayer_id: &RelayerId) -> Result<(), Box<dyn std::error::Error>> {
    println!("Listing pending and mempool transactions for relayer: {}", relayer_id);
    // TODO: Implement queue listing logic
    Ok(())
}

fn handle_cancel(tx_id: &TransactionId) -> Result<(), Box<dyn std::error::Error>> {
    println!("Canceling transaction: {}", tx_id);
    // TODO: Implement transaction cancellation logic
    Ok(())
}

fn handle_replace(tx_id: &TransactionId) -> Result<(), Box<dyn std::error::Error>> {
    println!("Replacing transaction: {}", tx_id);
    // TODO: Implement transaction replacement logic
    Ok(())
}

fn handle_send(relayer_id: &RelayerId) -> Result<(), Box<dyn std::error::Error>> {
    println!("Enter transaction details for relayer {}", relayer_id);
    // TODO: Implement transaction sending logic with user input
    Ok(())
}

fn log_transactions(transactions: Vec<Transaction>) -> Result<(), Box<dyn std::error::Error>> {
    if transactions.is_empty() {
        println!("No transactions found.");
        return Ok(());
    }

    if transactions.len() == 1 {
        let tx = &transactions[0];
        println!("\n┌─────────────────────────────────────────────────────────────────────");
        println!("│ TRANSACTION DETAILS");
        println!("├─────────────────────────────────────────────────────────────────────");
        println!("│ ID:                {}", tx.id);
        println!("│ Relayer:           {}", tx.relayer_id);
        println!("│ Status:            {}", tx.status);
        println!("│ From:              {}", tx.from);
        println!("│ To:                {}", tx.to);
        println!("│ Value:             {}", tx.value.into_inner().to_string());
        println!("│ Data:              {}", tx.data.hex());
        println!("│ Chain ID:          {}", tx.chain_id);
        println!("│ Speed:             {}", tx.speed);
        println!("│ Nonce:             {}", tx.nonce.into_inner());

        if let Some(gas_limit) = tx.gas_limit {
            println!("│ Gas Limit:         {}", gas_limit.into_inner());
        }

        if let Some(hash) = &tx.known_transaction_hash {
            println!("│ Tx Hash:           {}", hash);
        }

        if let Some(blobs) = &tx.blobs {
            println!("│ Blobs:             {}", blobs.len());
        }

        println!("│ Queued At:         {}", format_time(&tx.queued_at));
        println!("│ Expires At:        {}", format_time(&tx.expires_at));

        if let Some(sent_at) = &tx.sent_at {
            println!("│ Sent At:           {}", format_time(sent_at));
        }

        if let Some(mined_at) = &tx.mined_at {
            println!("│ Mined At:          {}", format_time(mined_at));
        }

        if let Some(gas) = &tx.sent_with_gas {
            println!(
                "│ Sent With Gas:     Max Priority Fee: {}, Max Fee: {}",
                gas.max_priority_fee.into_u128(),
                gas.max_fee.into_u128()
            );
        }

        if let Some(blob_gas) = &tx.sent_with_blob_gas {
            println!("│ Sent With Blob Gas: {:?}", blob_gas);
        }

        println!("└─────────────────────────────────────────────────────────────────────");
        return Ok(());
    }

    let mut rows = Vec::new();
    for tx in transactions.iter() {
        rows.push(vec![
            tx.id.to_string(),
            tx.relayer_id.to_string(),
            tx.status.to_string(),
            tx.from.hex(),
            tx.to.hex(),
            tx.value.into_inner().to_string(),
            format_status_with_time(tx),
        ]);
    }

    let headers = vec!["ID", "Relayer", "Status", "From", "To", "Value", "Timeline"];

    let title = format!("{} Transactions:", transactions.len());
    let footer = "Use 'transaction get <id>' to see more details about a specific transaction.";

    print_table(headers, rows, Some(&title), Some(footer));

    Ok(())
}

// Helper function to format SystemTime
fn format_time(time: &SystemTime) -> String {
    match time.duration_since(SystemTime::UNIX_EPOCH) {
        Ok(duration) => {
            let dt = chrono::DateTime::<chrono::Utc>::from_timestamp(
                duration.as_secs() as i64,
                duration.subsec_nanos(),
            )
                .unwrap_or_default();
            dt.format("%Y-%m-%d %H:%M:%S UTC").to_string()
        }
        Err(_) => "Invalid time".to_string(),
    }
}

// Helper function to format transaction status with relevant timestamp
fn format_status_with_time(tx: &Transaction) -> String {
    match tx.status {
        TransactionStatus::Pending => format!("Pending: {}", format_time(&tx.queued_at)),
        TransactionStatus::Inmempool => {
            if let Some(sent_at) = tx.sent_at {
                format!("In Mempool: {}", format_time(&sent_at))
            } else {
                "In Mempool".to_string()
            }
        }
        TransactionStatus::Mined => {
            if let Some(mined_at) = tx.mined_at {
                format!("Mined: {}", format_time(&mined_at))
            } else {
                "Mined".to_string()
            }
        }
        TransactionStatus::Confirmed => {
            if let Some(mined_at) = tx.mined_at {
                format!("Confirmed: {}", format_time(&mined_at))
            } else {
                "Confirmed".to_string()
            }
        }
        TransactionStatus::Failed => {
            if let Some(mined_at) = tx.mined_at {
                format!("Failed: {}", format_time(&mined_at))
            } else {
                "Failed".to_string()
            }
        }
        TransactionStatus::Expired => {
            format!("Expired: {}", format_time(&tx.expires_at))
        }
    }
}
